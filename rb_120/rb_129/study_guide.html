<!DOCTYPE html>
<html>
<head>
<title>study_guide.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="specific-topics-of-interest">Specific Topics of Interest</h1>
<h2 id="classes-and-objects">Classes and objects</h2>
<p>Object Oriented Programming, referred to as OOP, is a programming paradigm created to deal with the growing complexity of large software systems. One small change would trigger a ripple effect of errors due to dependencies throughout the program. A way was needed to create containers for data that could be managed and manipulated without affecting the entire program. This was solved using OOP.</p>
<p>Some features are:</p>
<p><strong>Encapsulation</strong> is hiding pieces of functionality and making it unavailable to the rest of the code of base, so that data cannot be changed or manipulated without obvious intention. Ruby accomplishes this task by creating objects and exposing interfaces (i.e., methods) to interact with those objects.</p>
<p>Objects offer a new-level of abstraction</p>
<p><strong>Polymorphism</strong> is the ability for different types of data to respond to a common interface. OOP gives us flexibility to use pre-written code for new purposes. For example, if we have a method that expects arguments that have a <code>move</code> method, we can pass it any type of argument, provided it has a compatible <code>move</code> method. It let's different types of objects respond to the same method invocation.</p>
<p>Another way polymorphism is applied is using <code>Modules</code>. They are similar to classes, however an object cannot be created with a module. A module must be mixed in with a class using the <code>include</code> method invocation. This is called <code>mixin</code>. The behaviours declared in a module ae availale to the class and its objects.</p>
<p><strong>Inheritance</strong> is where a class inherits the behaviours of another class, referred to as superclass. The class that inherits the behaviours is called subclass.</p>
<p>What are Objects?</p>
<p>Anything that can be said to have a value is an object like numbers, strings, arrays, classes, modules etc. However few things like methods, blocks and variables are not objects.</p>
<p>Objects are created from classes. Think of classes as molds and objects as the things you produce out of these molds. Individual objects will contain different information from other objects, yet they are instances of the same class. Example</p>
<pre class="hljs"><code><div>irb :001 &gt; <span class="hljs-string">"hello"</span>.class
=&gt; String
irb :002 &gt; <span class="hljs-string">"world"</span>.class
=&gt; String
</div></code></pre>
<p><em>Important Note: The phrase &quot;everything is an object&quot; is not strictly true. There are a few things in Ruby that are not objects, like methods, blocks, <code>if</code> statements, arguments lists etc.</em></p>
<p>The <code>class</code> instance method can be used to determine what class an object belongs to. Objects are intantiated from a class.</p>
<p>Ruby defines the attributes and behaviours of its objects in classes. Classes are a basic outline of what an object should be made of and what it should be able to do.</p>
<p>Classes are defined using a similar syntax as methods, the <code>def</code> is replaced with <code>class</code> and the CamelCase naming convention is used to create the name.</p>
<p>Example of class definition and instantiation:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span></span>
<span class="hljs-keyword">end</span>

sparky = GoodDog.new
</div></code></pre>
<p>The above code creates an instance of the class <code>GoodDog</code> and stores it in variable <code>sparky</code>. The entire workflow of creating a new object or instance of a class is called instantiation, so it can be said that we have instantiated an object called <code>sparky</code> from the class <code>GoodDog</code>. Object is returned by calling the class method <code>new</code>.</p>
<p>Objects of a class have two aspects - States and Behaviours which are defined in the class. States track attributes for individual objects. Behaviours are what objects are capable of doing. Instance variables are used to track this state information. Instance variables are scoped at the object (or instance) level and are how the objects keep track of their states.</p>
<p>Different objects of the same class contain indentical behaviours. For example 2 different <code>GoodDog</code> objects should be able to bark, run, fetch and perform other common behaviours of good dogs. These behaviours are defined as instance methods in a class. Instance methods are available to objects (or instances) of that class.</p>
<p>Basically :
Instance variables - keep track of state
Instance methods - expose behaviour for objects</p>
<p>Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(name)</span></span>
    @name = name
    puts <span class="hljs-string">"This object was initialized!"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sparky = GoodDog.new(<span class="hljs-string">"Sparky"</span>)  <span class="hljs-comment"># =&gt; "This object was initialized!"</span>
</div></code></pre>
<p>Calling the <code>new</code> class method leads us to the <code>initialize</code> instance method, which is also called a constructor method, because it is a special method that builds the object when a new object is instantiated. It gets triggered by the <code>new</code> class method.</p>
<p>Instance variables have the symbol <code>@</code> in front of it. They exist as long as the object instance exists. They do not die after the initialize method is run. They &quot;live on&quot;, to be referenced untill the object instance is destroyed. Above, the initialize method is defined with one parameter <code>name</code>. Arguments can be passed to the <code>initialize</code> instance method through the <code>new</code> class method as demonstrated above. The string <code>Sparky</code> is passed from the <code>new</code> method through to the <code>initialize</code> method, and is assigned to the local variable <code>name</code>. Within the contructor, the instance variable <code>@name</code> is set to <code>name</code> which results in assigning the string <code>&quot;Sparky&quot;</code> to the <code>@name</code> instance variable.</p>
<p>Every object's state is distinct and instance variables keep track of it.</p>
<p>Behaviours are defined by <strong>Instance Methods</strong>.</p>
<p>Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(name)</span></span>
    @name = name
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span></span>
    <span class="hljs-string">"<span class="hljs-subst">#{@name}</span> says Arf!"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sparky = GoodDog.new(<span class="hljs-string">"Sparky"</span>)
puts sparky.speak    <span class="hljs-comment"># =&gt; Sparky says Arf!</span>
</div></code></pre>
<p>The above program outputs the string <code>&quot;Sparky says Arf!&quot;</code></p>
<p>All objects instantiated of the <code>GoodDog</code> will have the same behavious though they contain different states. We can expose information about state of the objecy thorugh instance methods.</p>
<p>Every object will output their respective names, because of the string interpolation which accesses the value stored in instance variable <code>@name</code>.</p>
<h2 id="use-attr-to-create-setter-and-getter-methods">Use <code>attr_*</code> to create setter and getter methods</h2>
<p>If we want to access the instance variables of a class, we have to define a method which returns the object stored in the instance variable. We can modify the above code as follows with a method <code>get_name</code>, the job of this method is to return the value of the variable <code>@name</code>.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(name)</span></span>
    @name = name
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span></span>
    @name
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span></span>
    <span class="hljs-string">"<span class="hljs-subst">#{@name}</span> says Arf!"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sparky = GoodDog.new(<span class="hljs-string">"Sparky"</span>)
puts sparky.speak    <span class="hljs-comment"># =&gt; Sparky says Arf!</span>
puts sparky.name     <span class="hljs-comment"># =&gt; Sparky </span>
</div></code></pre>
<p>This is called a <em>getter</em> method.</p>
<p>If we want to change the name of <code>sparky</code>. Then we have to use a <em>setter</em> method, shown in the example below.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(name)</span></span>
    @name = name
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span></span>
    @name
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name=</span><span class="hljs-params">(name)</span></span>
    @name = name
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span></span>
    <span class="hljs-string">"<span class="hljs-subst">#{@name}</span> says Arf!"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sparky = GoodDog.new(<span class="hljs-string">"Sparky"</span>)
puts sparky.speak    <span class="hljs-comment"># =&gt; Sparky says Arf!</span>
puts sparky.name     <span class="hljs-comment"># =&gt; Sparky </span>
puts sparky.name = <span class="hljs-string">"Spartacus"</span>
puts sparky.name      <span class="hljs-comment"># =&gt; Spartacus</span>
</div></code></pre>
<p><code>puts sparky.name = &quot;Spartacus&quot;</code> is Ruby's special syntax for <code>puts sparky.name=(&quot;Spartacus&quot;)</code>.</p>
<p><em>Setter</em> methods always return the value that is passed in as an argument, regardless of what happens inside the method. If the setter method tries to return something other than the argument's value, it just ignores that attempt.</p>
<p>Ruby has a built in way to create getter and setter methods, using <code>attr_accessor</code> method.</p>
<p>The above code can be refactored as follows :</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span></span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:name</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(name)</span></span>
    @name = name
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span></span>
    <span class="hljs-string">"<span class="hljs-subst">#{@name}</span> says arf!"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sparky = GoodDog.new(<span class="hljs-string">"Sparky"</span>)
puts sparky.speak
puts sparky.name            <span class="hljs-comment"># =&gt; "Sparky"</span>
sparky.name = <span class="hljs-string">"Spartacus"</span>
puts sparky.name            <span class="hljs-comment"># =&gt; "Spartacus"</span>
</div></code></pre>
<p>The <code>attr_accessor</code> method takes a symbol as an argument which is used to create setter and getter methods. That one line replaced two method definitions.</p>
<p>Incase of only <em>getter</em> method - use method <code>attr_reader</code>
Incase of only <em>setter</em> method - use method <code>attr_writer</code>.</p>
<p>For multiple states the following syntax can be used</p>
<pre class="hljs"><code><div><span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">:height</span>, <span class="hljs-symbol">:weight</span>
</div></code></pre>
<h2 id="how-to-call-setters-and-getters">How to call setters and getters</h2>
<p>For accessing instance variables getter methods must be used rather than accessing them directly. This is also gives added flexibility to format the way the value of a variable is returned etc.</p>
<p>If setter method call is used to change the value of one or more instance variables within a class, then we must call it with <code>self</code> added to it. Like <code>self.name = </code>, else it will result in creation of local variables at the instance method level. This can be used for getter methods as well, though it is not required.</p>
<p><code>self.</code> that can also be prefixed for calling instance methods not just accessor methods.</p>
<p>While this works, the general rule from the Ruby style guide is to &quot;Avoid self where not required.&quot;</p>
<h2 id="instance-methods-vs-class-methods">Instance methods vs. class methods</h2>
<ul>
<li>Instance methods are methods that pertain to an instance or object of the class. There are also class level methods, called class methods. Class methods are methods that we can call directly on the class itself, without having to instantiate any objects.</li>
</ul>
<p>Example definition</p>
<pre class="hljs"><code><div><span class="hljs-comment"># ... rest of code ommitted for brevity</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">what_am_i</span>          <span class="hljs-comment"># Class method definition</span></span>
  <span class="hljs-string">"I'm a GoodDog class!"</span>
<span class="hljs-keyword">end</span>

puts GoodDog.what_am_i      <span class="hljs-comment"># Class method invocation</span>
</div></code></pre>
<ul>
<li>
<p>Class methods are where we put functionality that does not pertain to individual objects.</p>
</li>
<li>
<p>Instance variables capture information related to specific instances of classes (objects). We can create variables for an entire class, that are called <strong>class variables</strong>. Class variables are created using <code>@@</code>. An example showing the use of class variables.</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span></span>
  @@number_of_dogs = <span class="hljs-number">0</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>
    @@number_of_dogs += <span class="hljs-number">1</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">total_number_of_dogs</span></span>
    @@number_of_dogs
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

puts GoodDog.total_number_of_dogs     <span class="hljs-comment"># =&gt; 0</span>

dog1 = GoodDog.new
dog2 = GoodDog.new

puts GoodDog.total_number_of_dogs     <span class="hljs-comment"># =&gt; 2</span>
</div></code></pre>
<p>Since <code>initialize</code> gets called every time we instantiate a new object of the class with the <code>new</code> method, the class variable is incremented by 1 everytime an object is instantiated.</p>
<p><em>Class methods are sometimes confusingly called a &quot;singleton method&quot; (the term is used in other contexts as well). Good to know, not required to be used though.</em></p>
<h2 id="method-access-control">Method Access Control</h2>
<p>Method access control is generally implemented through the use of <em>access modifiers</em>. The purpose of access modifiers is to allow or restrict access to a particular thing (being the methods in a class).</p>
<p>In Ruby it is implemented through the use of <code>public</code>, <code>protected</code> and <code>private</code> access modifiers.</p>
<p><strong>Public method</strong> is a method that is available to anyone who knows either the class name or the object's name. These methods are readily available for the rest of the program to use and comprise the class's interface (that's how other classes and objects will interact with this class and its objects).</p>
<p><strong>Private method</strong> is a method that is doing work in the class but is not needed to be available to the rest of the program. To define a private method we use the <code>private</code> method call in our program and anything below it is private (unless another access modifier like <code>protected</code> is called after it to negate it). Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span></span>
  DOG_YEARS = <span class="hljs-number">7</span>

  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">:age</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(n, a)</span></span>
    <span class="hljs-keyword">self</span>.name = n
    <span class="hljs-keyword">self</span>.age = a
  <span class="hljs-keyword">end</span>

  private

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">human_years</span></span>
    age * DOG_YEARS
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>


sparky = GoodDog.new(<span class="hljs-string">"Sparky"</span>, <span class="hljs-number">4</span>)
sparky.human_years        <span class="hljs-comment"># =&gt; NoMethodError</span>
</div></code></pre>
<p>The private method <code>human_years</code> in the above code can be used within the class as follows:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span></span>
  ...

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">public_disclosure</span></span>
    <span class="hljs-string">"<span class="hljs-subst">#{<span class="hljs-keyword">self</span>.name}</span> in human years is <span class="hljs-subst">#{human_years}</span>"</span>
  <span class="hljs-keyword">end</span>

  private
  ...
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Note, we cannot use <code>self.human_years</code>, because <code>human_years</code> method is private. <code>self.human_years</code> is equivalent to <code>sparky.human_years</code>, which is not allowed for private methods. Hence, we just have to use <code>human_years</code>. So basically, private methods are not accessible outside the class definition at all, and are only accessible from inside the class when called without <code>self</code>.</p>
<p><strong>Protected Methods</strong> fall in between public and private methods. They are similar to private methods in that they cannot be invoked outside the class. The main difference between them is that protected methods allow access between class instances, while private methods do not.</p>
<p>Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(age)</span></span>
    @age = age
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">older?</span><span class="hljs-params">(other_person)</span></span>
    age &gt; other_person.age
  <span class="hljs-keyword">end</span>

  protected

  <span class="hljs-keyword">attr_reader</span> <span class="hljs-symbol">:age</span>
<span class="hljs-keyword">end</span>

malory = Person.new(<span class="hljs-number">64</span>)
sterling = Person.new(<span class="hljs-number">42</span>)

malory.older?(sterling)     <span class="hljs-comment"># =&gt; true</span>
sterling.older?(malory)     <span class="hljs-comment"># =&gt; false</span>

malory.age                  <span class="hljs-comment"># =&gt; NoMethodError</span>
</div></code></pre>
<p>It is clear that like private methods, protected methods cannot be invoked from outside of the class. However unlike private methods, other instances of the class (or subclass) can also invoke the method. This allows for controlled access, but wider access between objects of the same class type.</p>
<h2 id="referencing-and-setting-instance-variables-vs-using-getters-and-setters">Referencing and setting instance variables vs. using getters and setters</h2>
<h2 id="class-inheritance-encapsulation-and-polymorphism">Class inheritance, encapsulation, and polymorphism</h2>
<h3 id="inheritance">Inheritance:</h3>
<p>Inheritance is when a class inherits behaviour from another class. The class that is inheriting behaviour is called <em>subclass</em> and the class it inherits from is called <em>superclass</em>.</p>
<p>Inheritance is a way to extract common behaviour from classes that share that behviour and move it to a superclass. Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span></span>
    <span class="hljs-string">"Hello!"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span> &lt; Animal</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> &lt; Animal</span>
<span class="hljs-keyword">end</span>

sparky = GoodDog.new
paws = Cat.new
puts sparky.speak       <span class="hljs-comment"># =&gt; Hello!</span>
puts paws.speak         <span class="hljs-comment"># =&gt; Hello!</span>
</div></code></pre>
<p>The symbol <code>&lt;</code> is used to signify that <code>GoodDog</code> and <code>Cat</code> classed are inheriting from <code>Animal</code> class. All methods of class <code>Animal</code> are available to both the classes for use. In the above code, both the classes are using the superclass <code>Animal</code>'s <code>speak</code> method.</p>
<p>If we wanted to added special functionality in the <code>speak</code> method for any one of our sub-classes we can define another method <code>speak</code> in that subclass thereby overriding the <code>speak</code> method in <code>Animal</code>. Ruby will look up the Method Lookup Path. If it finds a method in the class it will execute that else, it will look for the method above in the method lookup path. \</p>
<p>Inheritance is a way of removing duplication in code. &quot;DRY&quot; means Don't Repeat Yourself. It means that if you find yourself writing the same logic over and over again in your programs, there are ways to extract that logic to one place for reuse.</p>
<h3 id="polymorphism">Polymorphism</h3>
<p>Polymorphism refers to the ability of different object types to respond to the same method invocation, often but not always, in different ways. In other words, data of different types can respond to a common interface. It's a crucial concept in OO programming that can lead to more maintainable code.</p>
<p>When two or more objects types have a method with the same name, we can invoke that method with any of those objects. When we don't care what type of object is calling the method, we're using polymorphism. Polymorphism might be implemented by inheritance or without it as well.</p>
<p>Examples :</p>
<p><em>Polymorphism through inheritance</em></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span></span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span> &lt; Animal</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span></span>
    puts <span class="hljs-string">"swim"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> &lt; Animal</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span></span>
    puts <span class="hljs-string">"walk"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sponge</span> &lt; Animal;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coral</span> &lt; Animal;</span> <span class="hljs-keyword">end</span>

animals = [Fish.new, Cat.new, Sponge.new, Coral.new]
animals.each { <span class="hljs-params">|animal|</span> animal.move }
</div></code></pre>
<p>Every object in the array is a different animal, but the client code (the code that uses those objects) doesn't care what each object is. The only thing required is that each object have a <code>move</code> method that requires no arguments. The interface for this class hierarchy lets us work with all of those types in the same way even though the implementations may be dramatically different. This is polymorphism.</p>
<p>Looking at each object :</p>
<p>The <code>Sponge</code> and <code>Coral</code> classes don't have a <code>move</code> method (at least not one of their own). They both inherit from the <code>Animal</code> class. Thus, for both objects belonging to these classesm the <code>move</code> method in the class <code>Animal</code> is called. This is polymorphism through inheritance, inside of providing their own behavior for the <code>move</code> method, inheritance is used to acquire the behviour of a superclass.</p>
<p>For <code>Fish</code> object, we call <code>move</code> method from the <code>Fish</code> class which enables a fish to swim. For the <code>Cat</code> object, we call <code>move</code> method from the <code>Cat</code> class which enables a cat to walk. Here polymorphism is demonstrated by the fact that two  different object types can respond to the same method call simply by overriding a method inherited from a superclass.</p>
<p><em>Polymorphism through duck typing</em></p>
<p>Duck typing occurs when objects of different unrelated types both respond to the same method name. The class or type of object is not important, what is important is that if an object has a particular behaviour. &quot;If an object quacks like duck, then we can treat it as a duck&quot;. Duck typing is a form of polymorphism. As long as the objects involved use the same method name and take the same number of arguments, we can treat the object as belonging to a specific category of objects.</p>
<p>Example: (needs to be verified)</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Batsman</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span></span>
    <span class="hljs-string">"Bat"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bowler</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span></span>
    <span class="hljs-string">"Bowl"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fielder</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span></span>
    <span class="hljs-string">"Field"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CricketGame</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_game</span><span class="hljs-params">(players)</span></span>
    players.each { <span class="hljs-params">|player|</span> player.play}
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

game = CricketGame.new

game.start_game([Batsman.new, Bowler.new, Fielder.new])
</div></code></pre>
<p>One important note - <em>polymorphic methods are intentionally designed to be polymorphic, if there's no intention, you probably shouldn't use them polymorphically</em>.</p>
<p>Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blinds</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>In theory the methods above can be used polymorphically as they are both named <code>draw</code> and take no arguments. However, for a circle it probably means to draw a circle and for blinds it means to open or close blinds. So even, though they can be used polymorphically, this is not polymorphism as it is unlikely to make sense or help in the code. Unless you are calling the methods in a polymorphic manner (with intent), you don't have polymorphism.</p>
<h3 id="encapsulation">Encapsulation</h3>
<p>Encapsulation lets us hide the internal representation of an object from the outside and only expose methods and properties that users of the object need. Method access control can be used to expose those properties and methods through the public interface of a class: it's public methods.</p>
<p>Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>
  <span class="hljs-keyword">attr_reader</span> <span class="hljs-symbol">:nickname</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(n)</span></span>
    @nickname = n
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_nickname</span><span class="hljs-params">(n)</span></span>
    <span class="hljs-keyword">self</span>.nickname = n
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greeting</span></span>
    <span class="hljs-string">"<span class="hljs-subst">#{nickname.capitalize}</span> says Woof Woof!"</span>
  <span class="hljs-keyword">end</span>

  private

  <span class="hljs-keyword">attr_writer</span> <span class="hljs-symbol">:nickname</span>
<span class="hljs-keyword">end</span>

dog = Dog.new(<span class="hljs-string">"rex"</span>)
dog.change_nickname(<span class="hljs-string">"barny"</span>)  <span class="hljs-comment"># changed nickname to "barny"</span>
puts dog.greeting             <span class="hljs-comment"># =&gt; Barny says Woof Woof!</span>
</div></code></pre>
<p>In the example we change the nickname of the dog by calling the <code>change_nickname</code> method without needing to know how the <code>Dog</code> class and this method are implemented.</p>
<p>Similary, when <code>greeting</code> is called on a <code>Dog</code> object. The greeting is output with the name capitalized. Again, the method implementation is hidden. Its important to note that <code>setter</code> method for <code>nickname</code> is private. If we try to call it like <code>dog.nickname = &quot;barny&quot;</code> it would raise an error.</p>
<p><em><strong>One important distinction to note here is that even though the <code>setter</code> method for <code>nickname</code> is private, it is being called with <code>self</code> prepended within the <code>change_nickname</code> method. This is an exception in Ruby, <code>self</code> must be used to call private <code>setter</code> methods, if not used Ruby would think a new local variable is being created.</strong></em></p>
<h2 id="modules">Modules</h2>
<p>Another way of DRY up code is using <em>Modules</em>. Modules can be used to extract common behaviour in one place. The module can then be mixed in also known as mixin to different classes which gives access to the methods defined in the module. A module is added to a class by invoking the <code>include</code> method. Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Swimmable</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swim</span></span>
    <span class="hljs-string">"I'm swimming!"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span> &lt; Animal</span>
  <span class="hljs-keyword">include</span> Swimmable
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mammal</span> &lt; Animal</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> &lt; Mammal</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> &lt; Mammal</span>
  <span class="hljs-keyword">include</span> Swimmable
<span class="hljs-keyword">end</span>

sparky = Dog.new
neemo = Fish.new
paws = Cat.new

sparky.swim       <span class="hljs-comment"># =&gt; I'm swimming!</span>
neemo.swim        <span class="hljs-comment"># =&gt; I'm swimming!</span>
paws.swim         <span class="hljs-comment"># =&gt; NoMethodError</span>
</div></code></pre>
<p>A common naming convention for Ruby is to &quot;able&quot; suffix on whatever verb describes the behaviour that the module is modelling.</p>
<p>Points to not for mixing in modules(interface inheritance) vs class inheritance :</p>
<ul>
<li>You can only subclass from one class, however you can mix in as many modules as you like.</li>
<li>If there is an &quot;is-a&quot; relationship, class inheritance is usually the choice. If there's a &quot;has-a&quot; relationship, interface inheritance is generally a better choice. Example, a dog &quot;is an&quot; animal and it &quot;has an&quot; ability to swim.</li>
<li>You cannot instantiate modules (no object can be created from a module). Modules are used only for namespacing and grouping common methods together.</li>
</ul>
<p>There are other uses for modules as well.</p>
<p><strong>Namespacing</strong>
In this context, namespacing means organizing similar classes under a module. In other words, using modules to group related classes. It makes it easier to recognize related classes in our code, also it reduces the likelihood of our classes colliding with other similarly named classes in the codebase.</p>
<p>Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Mammal</span></span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span><span class="hljs-params">(sound)</span></span>
      p <span class="hljs-string">"<span class="hljs-subst">#{sound}</span>"</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span></span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_name</span><span class="hljs-params">(name)</span></span>
      p <span class="hljs-string">"<span class="hljs-subst">#{name}</span>"</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Classes in modules are called by appending the class name to the module name with two colons <code>::</code> as follows:</p>
<pre class="hljs"><code><div>buddy = Mammal::Dog.new
kitty = Mammal::Cat.new
buddy.speak(<span class="hljs-string">'Arf!'</span>)       <span class="hljs-comment"># =&gt; "Arf!"</span>
kitty.say_name(<span class="hljs-string">'kitty'</span>)   <span class="hljs-comment"># =&gt; "kitty"</span>
</div></code></pre>
<p><strong>Container</strong>
Modules can be used a container for methods, called module methods. Here modules are used to house other methods. It's useful for methods that seem out of place in the code. Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Mammal</span></span>
  ...

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">some_out_of_place_method</span><span class="hljs-params">(num)</span></span>
    num ** <span class="hljs-number">2</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>The method can be called in the two ways demonstrated below. The first way is the preffered way.</p>
<pre class="hljs"><code><div>value = Mammal.some_out_of_place_method(<span class="hljs-number">4</span>)
value = Mammal::some_out_of_place_method(<span class="hljs-number">4</span>)
</div></code></pre>
<h2 id="method-lookup-path">Method lookup path</h2>
<p>Method lookup path is the order in which classes are inspected when a method is called.
Can also be written as - The method lookup path is the order in which Ruby will traverse the class hierarchy to look for methods to invoke.</p>
<p>Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Walkable</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk</span></span>
    <span class="hljs-string">"I'm walking."</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Swimmable</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swim</span></span>
    <span class="hljs-string">"I'm swimming."</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Climbable</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climb</span></span>
    <span class="hljs-string">"I'm climbing."</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>
  <span class="hljs-keyword">include</span> Walkable

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span></span>
    <span class="hljs-string">"I'm an animal, and I speak!"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span> &lt; Animal</span>
  <span class="hljs-keyword">include</span> Swimmable
  <span class="hljs-keyword">include</span> Climbable
<span class="hljs-keyword">end</span>

puts GoodDog.ancestors
</div></code></pre>
<p>Output:</p>
<pre class="hljs"><code><div>GoodDog
Climbable
Swimmable
Animal
Walkable
Object
Kernel
BasicObject
</div></code></pre>
<p>Here we, can see the order in which Ruby looks up the classes and modules. The module included last is searched first. Also, it is interesting to note that the module <code>Walkable</code> also made it's way in the method lookup path. Hence, the module / modules included in the superclasses also become available to the subclasss.</p>
<h2 id="self"><code>self</code></h2>
<p>If setter method call is used to change the value of one or more instance variables within a class, then we must call it with <code>self</code> added to it. Like <code>self.name = </code>, else it will result in creation of local variables at the instance method level. This can be used for getter methods as well, though it is not required.</p>
<p><code>self.</code> that can also be prefixed for calling instance methods not just accessor methods.</p>
<p>While this works, the general rule from the Ruby style guide is to &quot;Avoid self where not required.&quot;</p>
<h2 id="calling-methods-with-self-more-about-self">Calling methods with self, More about <code>self</code></h2>
<p><code>self</code> can refer to different things depending on where it is used.</p>
<ul>
<li>for calling setter methods from within the class. We use <code>self</code> to allow Ruby to disambiguate between initializing a local variable and calling a setter method.</li>
<li>for class method definitions</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span></span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">:height</span>, <span class="hljs-symbol">:weight</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(n, h, w)</span></span>
    <span class="hljs-keyword">self</span>.name   = n
    <span class="hljs-keyword">self</span>.height = h
    <span class="hljs-keyword">self</span>.weight = w
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_info</span><span class="hljs-params">(n, h, w)</span></span>
    <span class="hljs-keyword">self</span>.name   = n
    <span class="hljs-keyword">self</span>.height = h
    <span class="hljs-keyword">self</span>.weight = w
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">info</span></span>
    <span class="hljs-string">"<span class="hljs-subst">#{<span class="hljs-keyword">self</span>.name}</span> weighs <span class="hljs-subst">#{<span class="hljs-keyword">self</span>.weight}</span> and is <span class="hljs-subst">#{<span class="hljs-keyword">self</span>.height}</span> tall."</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">what_is_self</span></span>
    <span class="hljs-keyword">self</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sparky = GoodDog.new(<span class="hljs-string">'Sparky'</span>, <span class="hljs-string">'12 inches'</span>, <span class="hljs-string">'10 lbs'</span>)
p sparky.what_is_self
<span class="hljs-comment"># =&gt; #&lt;GoodDog:0x007f83ac062b38 <span class="hljs-doctag">@name</span>="Sparky", <span class="hljs-doctag">@height</span>="12 inches", <span class="hljs-doctag">@weight</span>="10 lbs"&gt;</span>
</div></code></pre>
<p>What does <code>self</code> really represent?</p>
<p>From within the class when an instance method uses <code>self</code>, it refernces the calling object (instance).  Therefore from within the <code>change_info</code> method, calling <code>self.name=</code> acts the same as calling <code>spark.name=</code> from outside the class (you can't call <code>sparky.name=</code> inside the class, though, since it isn't in scope). In this case <code>self</code>
represents the object referenced by <code>sparky</code>.</p>
<p>When <code>self</code> is prepended to a method definition, it is defining a <strong>class method</strong>. Like in the earlier example with the class method called <code>self.total_number_of_dogs</code>. Using <code>self</code> inside a class but outside of an instance method refers to the class itself. Let's see the code below for example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodDog</span></span>
  <span class="hljs-comment"># ... rest of code omitted for brevity</span>
  puts <span class="hljs-keyword">self</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Here <code>GoodDog</code> will be output. Sence <code>def self.total_number_of_dogs</code> is equivalent to <code>def GoodDog.total_number_of_dogs</code>.</p>
<p>To be clear :</p>
<ul>
<li><code>self</code> inside an instance method refernces the instance (object) that called the method.</li>
<li><code>self</code> outside of an instance method, references the class and can be used to define class methods.</li>
</ul>
<p>Therefore, <code>self</code> is a way of being explicit about what our program is referencing and what our intentions are as far as behaviour. <code>self</code> changes depenidng on the scope it is used in.</p>
<h2 id="reading-oo-code">Reading OO code</h2>
<h2 id="fake-operators-and-equality">Fake operators and equality</h2>
<h3 id="equivalence">Equivalence</h3>
<p>Equivalence in Ruby can be summarized as follows:</p>
<p><code>==</code></p>
<ul>
<li>for most objects <code>==</code> compares the values of the objects</li>
<li><code>==</code> operator is actually a method. Most built-in classes in Ruby like <code>Array</code>, <code>String</code>, <code>Integer</code> etc. provide their own <code>==</code> method, and this defines how the objects of those classes are compared.</li>
<li><code>BasicObject#==</code> does not perform an equality check, instead it returns true if two objects are the same object. Hence, classes must provide their own behaviour for the method <code>==</code>.</li>
<li>In order to compare custom objects, the <code>==</code> method must be defined.</li>
</ul>
<p><code>equal?</code></p>
<ul>
<li><code>equal?</code> method does not only determine if two variables have the same value, but also whether they point to the same object.</li>
<li><code>equal?</code> should not be defined.</li>
<li>it's not often used</li>
<li>comparing the <code>object_id</code> of two objects has the same effect as comparing them with <code>equal?</code>.</li>
</ul>
<p><code>===</code></p>
<ul>
<li>used implicitly in <code>case</code> statements.</li>
<li>like <code>==</code>, the <code>===</code> operator is actually a method</li>
<li>this method is rarely called explicitly. And it is defined very rarely, in case you anticipate your objects will be used in <code>case</code> statements.</li>
</ul>
<p><code>eql?</code></p>
<ul>
<li><code>eql?</code> method determines if two objects contain the same value and if they're of the same class. Used by <code>Hash</code> to determine equality among its members.</li>
<li>used implicitly by <code>Hash</code>.</li>
<li>very rarely used explicitly</li>
</ul>
<p>Equivalence though seemingly simple is a actually a little complicated.</p>
<p>A string, integer, symbol is equal to another string, integer, symbol of the same value respectively.</p>
<p>When compared using the operator <code>==</code> they should return true if the value is the same.</p>
<pre class="hljs"><code><div>str1 = <span class="hljs-string">"something"</span>
str2 = <span class="hljs-string">"something"</span>
str1 == str2            <span class="hljs-comment"># =&gt; true</span>

int1 = <span class="hljs-number">1</span>
int2 = <span class="hljs-number">1</span>
int1 == int2            <span class="hljs-comment"># =&gt; true</span>

sym1 = <span class="hljs-symbol">:something</span>
sym2 = <span class="hljs-symbol">:something</span>
sym1 == sym2            <span class="hljs-comment"># =&gt; true</span>
</div></code></pre>
<p>When we are comparing <code>str1</code> and <code>str2</code> using <code>==</code> we are comparing the values not that are the two objects the same. Here the method <code>equal?</code> comes in use. The method <code>equal?</code> checks whether the two objects are the same only.</p>
<p>Example:</p>
<pre class="hljs"><code><div>str1 = <span class="hljs-string">"something"</span>
str2 = <span class="hljs-string">"something"</span>
str1_copy = str1

str1 == str2            <span class="hljs-comment"># =&gt; true</span>
str1 == str1_copy       <span class="hljs-comment"># =&gt; true</span>
str2 == str1_copy       <span class="hljs-comment"># =&gt; true</span>

str1.equal?(str2)       <span class="hljs-comment"># =&gt; false</span>
str1.equal?(str1_copy)  <span class="hljs-comment"># =&gt; true</span>
str2.equal?(str1_copy)  <span class="hljs-comment"># =&gt; false</span>
</div></code></pre>
<p>It can be clearly seen above that <code>str1</code> and <code>str1_copy</code> point to the same object and hence the method <code>equal?</code> returns true when comparing them.</p>
<p>Basically the method <code>==</code> compares the two variables' values wheras the method <code>equal?</code> determines whether the two variables point to the same object.</p>
<p>The <code>==</code> method:</p>
<p>The original <code>==</code> method is defined in the <code>BasicObject</code> class, which is the parent class for all classes in Ruby. This implies that every object in Ruby has <code>==</code> method. However each class should define the method <code>==</code> to specify the value to compare.</p>
<p><code>==</code> though looks like an operator is actually a method. <code>str1 == str2</code> is actually a method call <code>str1.==(str2)</code>.</p>
<p>We can define the <code>==</code> method for classes which helps to specify the value to compare.</p>
<p>Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:name</span>
<span class="hljs-keyword">end</span>

bob = Person.new
bob.name = <span class="hljs-string">"bob"</span>

bob2 = Person.new
bob2.name = <span class="hljs-string">"bob"</span>

bob == bob2     <span class="hljs-comment"># false, this is the `BasicObject#==` method, which sees if both are pointing to the same object (same as equal?)</span>

bob_copy = bob
bob == bob_copy  <span class="hljs-comment"># true, they both are pointing to the same object</span>
</div></code></pre>
<p>Hoever, we can define the <code>==</code> in our <code>Person</code> class to tell Ruby what <code>the same</code> means for a <code>Person</code> object.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:name</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">==</span><span class="hljs-params">(other)</span></span>
    name == other.name
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

bob = Person.new
bob.name = <span class="hljs-string">"bob"</span>

bob2 = Person.new
bob2.name = <span class="hljs-string">"bob"</span>

bob == bob2           <span class="hljs-comment"># =&gt; true, the names of the two objects are compared</span>
</div></code></pre>
<p>In this case by defining the <code>==</code> method we are overriding the default <code>BasicObject#==</code> method and providing a more suitable way to compare two <code>Person</code> objects.</p>
<p>Important Note: The <code>Person#==</code> method is actually using the <code>String#==</code> method for comparison. Every core library class will have its own <code>==</code> method which can be used to compare <code>Array</code>, <code>Hash</code>, <code>Integer</code>, <code>String</code> and other objects.</p>
<p>Comparing object_ids of two objects (which we can get from the method <code>object_id</code>) have the same effect as the method <code>equal?</code>.</p>
<p>Example:</p>
<pre class="hljs"><code><div>str = <span class="hljs-string">"something"</span>
str_copy = str

str.object_id == str_copy.object_id     <span class="hljs-comment"># =&gt; true</span>
str.equal?(str_copy)                    <span class="hljs-comment"># =&gt; true</span>
</div></code></pre>
<p>The <code>===</code> method</p>
<p><code>===</code> is also an instance method like <code>==</code>. It's actually used implicitly in the <code>case</code> statement.</p>
<p>Example:</p>
<pre class="hljs"><code><div>num = <span class="hljs-number">25</span>

<span class="hljs-keyword">case</span> num
<span class="hljs-keyword">when</span> <span class="hljs-number">1</span>..<span class="hljs-number">50</span>
  puts <span class="hljs-string">"small number"</span>
<span class="hljs-keyword">when</span> <span class="hljs-number">51</span>..<span class="hljs-number">100</span>
  puts <span class="hljs-string">"large number"</span>
<span class="hljs-keyword">else</span>
  puts <span class="hljs-string">"not in range"</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Since all comparisons above are with ranges, here the <code>Range#===</code> method is being used. Whats actually happening is as follows:</p>
<pre class="hljs"><code><div>num = <span class="hljs-number">25</span>

<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>..<span class="hljs-number">50</span>) === num
  puts <span class="hljs-string">"small number"</span>
<span class="hljs-keyword">elsif</span> (<span class="hljs-number">51</span>..<span class="hljs-number">100</span>) === num
  puts <span class="hljs-string">"large number"</span>
<span class="hljs-keyword">else</span>
  puts <span class="hljs-string">"not in range"</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Basically the way <code>===</code> works, is like it's asking &quot;if <code>(1..50)</code> is a group, would <code>25</code> belong in that group?&quot;</p>
<p>Example:</p>
<pre class="hljs"><code><div>String === <span class="hljs-string">"hello"</span>  <span class="hljs-comment"># =&gt; true, "hello" is an instance of String</span>
String === <span class="hljs-number">15</span>       <span class="hljs-comment"># =&gt; false, 15 is not an instance of String</span>
Integer === <span class="hljs-number">15</span>      <span class="hljs-comment"># =&gt; true, 15 is an instance of Integer</span>
</div></code></pre>
<h3 id="fake-operators">Fake Operators</h3>
<p>Many methods in Ruby look like operators like <code>==</code>, <code>&lt;</code>, <code>&gt;</code> etc. Below is a table that shows which operators are real operators and which ones are methods disguised as operators (listed by order of precedence, highest first) :</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>no</td>
<td><code>.</code>,<code>::</code></td>
<td>Method/constant resolution operators</td>
</tr>
<tr>
<td>yes</td>
<td><code>[]</code>,<code>[]=</code></td>
<td>Collection element getter and setter.</td>
</tr>
<tr>
<td>yes</td>
<td><code>**</code></td>
<td>Exponential operator</td>
</tr>
<tr>
<td>yes</td>
<td><code>!</code>,<code>~</code>,<code>+</code>,<code>-</code></td>
<td>Not, complement, unary plus and minus (method names for the last two are +@ and -@)</td>
</tr>
<tr>
<td>yes</td>
<td><code>*</code>,<code>/</code>,<code>%</code></td>
<td>Multiply, divide, and modulo</td>
</tr>
<tr>
<td>yes</td>
<td><code>+</code>,<code>-</code></td>
<td>Plus, minus</td>
</tr>
<tr>
<td>yes</td>
<td><code>&gt;&gt;</code>,<code>&lt;&lt;</code></td>
<td>Right and left shift</td>
</tr>
<tr>
<td>yes</td>
<td><code>&amp;</code></td>
<td>Bitwise &quot;and&quot;</td>
</tr>
<tr>
<td>yes</td>
<td><code>^</code>,<code>|</code></td>
<td>Bitwise exclusive &quot;or&quot; and regular &quot;or&quot; (inclusive &quot;or&quot;)</td>
</tr>
<tr>
<td>yes</td>
<td><code>&lt;=</code>,<code>&lt;</code>,<code>&gt;</code>,<code>&gt;=</code></td>
<td>Less than/equal to, less than, greater than, greater than/equal to</td>
</tr>
<tr>
<td>yes</td>
<td><code>&lt;=&gt;</code>,<code>==</code>,<code>===</code>,<code>!=</code>,<code>=~</code>,<code>!~</code></td>
<td>Equality and pattern matching (<code>!=</code>and<code>!~</code>cannot be directly defined)</td>
</tr>
<tr>
<td>no</td>
<td><code>&amp;&amp;</code></td>
<td>Logical &quot;and&quot;</td>
</tr>
<tr>
<td>no</td>
<td><code>||</code></td>
<td>Logical &quot;or&quot;</td>
</tr>
<tr>
<td>no</td>
<td><code>..</code>,<code>...</code></td>
<td>Inclusive range, exclusive range</td>
</tr>
<tr>
<td>no</td>
<td><code>? :</code></td>
<td>Ternary if-then-else</td>
</tr>
<tr>
<td>no</td>
<td><code>=</code>,<code>%=</code>,<code>/=</code>,<code>-=</code>,<code>+=</code>,<code>|=</code>,<code>&amp;=</code>,<code>&gt;&gt;=</code>,<code>&lt;&lt;=</code>,<code>*=</code>,<code>&amp;&amp;=</code>,<code>||=</code>,<code>**=</code>,<code>{</code></td>
<td>Assignment (and shortcuts) and block delimiter</td>
</tr>
</tbody>
</table>
<p>Hence, we can see that many operators which are actually methods and can be defined in our classes to change their default behaviors. Such fake operators can be defined and made to work the way we intend to.</p>
<p>Many operators (methods) are overridden to provide fake operators.</p>
<p><strong>Equality methods</strong></p>
<ul>
<li>One of the most common fake operators is <code>==</code>. Defining <code>==</code> method also gives us <code>!=</code> method automatically.</li>
</ul>
<p><strong>Comparison methods</strong></p>
<p>Defining a comparison method, give us really nice syntax for comparing objects.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">:age</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(name, age)</span></span>
    @name = name
    @age = age
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">&gt;</span><span class="hljs-params">(other_person)</span></span>
    age &gt; other_person.age
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

bob = Person.new(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">49</span>)
kim = Person.new(<span class="hljs-string">"Kim"</span>, <span class="hljs-number">33</span>)


puts <span class="hljs-string">"bob is older"</span> <span class="hljs-keyword">if</span> bob &gt; kim    <span class="hljs-comment"># =&gt; "bob is older"</span>

<span class="hljs-comment"># alternate syntax</span>

puts <span class="hljs-string">"bob is older"</span> <span class="hljs-keyword">if</span> bob.&gt;(kim)   <span class="hljs-comment"># =&gt; "bob is older"</span>
</div></code></pre>
<p>In the code above the age of the two objects of class <code>Person</code> is being compared. The comparison functionality is being pushed to the <code>Integer#&gt;</code> method. The method <code>Person#&gt;</code> can be used in conditionals.</p>
<p>Defining <code>&gt;</code> doesn't automatically give us <code>&lt;</code>. We need to define it separately.</p>
<p><code>&lt;&lt;</code> method</p>
<p>Fake operator can also be used for the <code>&lt;&lt;</code> which is actually a method. It's best used when working with a class that represents a collection.</p>
<p><code>+</code> method</p>
<p>Even <code>+</code> is a method. so <code>1 + 1</code> is actually <code>1.+(1)</code> which returns <code>2</code>.</p>
<p>We can write a <code>+</code> method for our own objects. The way Ruby's standard library implements is as follows :</p>
<ul>
<li><code>Integer#+</code>: increments the value by value of the argument, returning a new integer</li>
<li><code>String#+</code>: concatenates with argument, returning a new string</li>
<li><code>Array#+</code>: concatenates with argument, returning  a new array</li>
<li><code>Date#+</code>: increments the date in days by value of the argument, returning a new date</li>
</ul>
<p>It's generally a good idea to follow the general usage of a method as in the standard libraries.</p>
<p>Element setter and getter methods - <code>[]</code>, <code>[]=</code></p>
<p>Element setter and getter methods <code>[]=</code> and <code>[]</code> are most commonly used for arrays. These are also methods. The syntactical sugar is a little too extreme though :</p>
<pre class="hljs"><code><div>array = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]

<span class="hljs-comment"># element refernce</span>
array[<span class="hljs-number">2</span>]          <span class="hljs-comment"># =&gt; 'c'</span>

<span class="hljs-comment"># it's actually a method call</span>
array.[](<span class="hljs-number">2</span>)       <span class="hljs-comment"># =&gt; 'c'</span>

<span class="hljs-comment"># element assignment</span>
array[<span class="hljs-number">4</span>] = <span class="hljs-string">'e'</span>
p array           <span class="hljs-comment"># =&gt; ['a', 'b', 'c', 'd', 'e']</span>

<span class="hljs-comment"># it's also a method call</span>
array.[]=(<span class="hljs-number">5</span>, <span class="hljs-string">'f'</span>)
p array           <span class="hljs-comment"># =&gt; ['a', 'b', 'c', 'd', 'e', 'f']</span>
</div></code></pre>
<p>When defining <code>[]</code> and <code>[]=</code> methods for our own classes we must keep in mind the way it's used in the standard library. It's usually good for classes that represent a collection. However, being instance methods they can be defined to bo whatever we want, but it is not a good idea generally.</p>
<p>Sample code showing all the fake operators in action:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">:age</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(name, age)</span></span>
    @name = name
    @age = age
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">&gt;</span><span class="hljs-params">(other_person)</span></span>
    age &gt; other_person.age
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Team</span></span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">:members</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(name)</span></span>
    @name = name
    @members = []
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">&lt;&lt;</span><span class="hljs-params">(person)</span></span>
    members.push(person)
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">+</span><span class="hljs-params">(other_team)</span></span>
    temp_team = Team.new(<span class="hljs-string">"Temporary Team"</span>)
    temp_team.members = members + other_team.members
    temp_team
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">[]</span><span class="hljs-params">(idx)</span></span>
    members[idx]
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">[]=</span><span class="hljs-params">(idx, obj)</span></span>
    members[idx] = obj
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

cowboys = Team.new(<span class="hljs-string">"Dallas Cowboys"</span>)
cowboys &lt;&lt; Person.new(<span class="hljs-string">"Troy Aikman"</span>, <span class="hljs-number">48</span>)
cowboys &lt;&lt; Person.new(<span class="hljs-string">"Emmitt Smith"</span>, <span class="hljs-number">46</span>)
cowboys &lt;&lt; Person.new(<span class="hljs-string">"Michael Irvin"</span>, <span class="hljs-number">49</span>)


niners = Team.new(<span class="hljs-string">"San Francisco 49ers"</span>)
niners &lt;&lt; Person.new(<span class="hljs-string">"Joe Montana"</span>, <span class="hljs-number">59</span>)
niners &lt;&lt; Person.new(<span class="hljs-string">"Jerry Rice"</span>, <span class="hljs-number">52</span>)
niners &lt;&lt; Person.new(<span class="hljs-string">"Deion Sanders"</span>, <span class="hljs-number">47</span>)

dream_team = cowboys + niners
dream_team.name = <span class="hljs-string">"Dream Team"</span>

dream_team[<span class="hljs-number">4</span>]
dream_team[<span class="hljs-number">5</span>] = Person.new(<span class="hljs-string">"JJ"</span>, <span class="hljs-number">72</span>)

puts dream_team.inspect
</div></code></pre>
<h2 id="working-with-collaborator-objects-read-no-object-is-an-island-on-medium">Working with collaborator objects (READ no object is an island on Medium)</h2>
<p>Classes group common behaviour and objects encapsulate state. Object's states are saved in an object's instance variables. Instance methods operate on those instance variables. The instance variables can hold objects belonging to classes such as <code>String</code>, <code>Integer</code> etc., also collections like <code>Array</code>, <code>Hash</code>, etc. or even an object of a custom class we've created. Objects that are stored as state within another object are called &quot;collaborator objects&quot;.</p>
<p>They are called collaborators because they work in conjunction (or in collaboration) with the class they are associated with.</p>
<p>Example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">:pet</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(name)</span></span>
    @name = name
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulldog</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span></span>
    puts <span class="hljs-string">"bark!"</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fetch</span></span>
    puts <span class="hljs-string">"fetching!"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

bob = Person.new(<span class="hljs-string">"Robert"</span>)
bud = Bulldog.new

bob.pet = bud                 <span class="hljs-comment"># `bob`'s `<span class="hljs-doctag">@pet</span>` now points to `bud` which is a `Bulldog` object.</span>

bob.pet                       <span class="hljs-comment"># =&gt; #&lt;Bulldog:0x007fd8399eb920&gt;</span>
bob.pet<span class="hljs-class">.<span class="hljs-keyword">class</span>                 <span class="hljs-comment"># =&gt; Bulldog</span></span>

bob.pet.speak                 <span class="hljs-comment"># =&gt; "bark!"</span>
bob.pet.fetch                 <span class="hljs-comment"># =&gt; "fetching!"</span>
</div></code></pre>
<p>Here, for <code>bob</code> we have a collaborator object stored in <code>@pet</code> variable. When we need that <code>Bulldog</code> object to perform some action, we can go through <code>bob</code> and call the method on the object stored in <code>@pet</code> such <code>speak</code> or <code>fetch</code>.</p>
<p>When we work with collaborator objects, they are usually custom objects of user defined classes. However, collaborator objects aren't strictly custom objects. Even the string object stored in <code>@name</code> within <code>bob</code> in the code above is technically a collaborator object.</p>
<p>Collaborator objects play an important role in OO design. They also represent the connection between various classes in your program. They allow you to chop up and modularize the problem domain into cohesive pieces; they are at the core of OO programming and play an important role in modelling complicated problem domains.</p>

</body>
</html>
